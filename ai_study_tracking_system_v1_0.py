# -*- coding: utf-8 -*-
"""AI Study Tracking System -V1.0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ab5doEkeyPfTVZek3HPqg1-zNYfy-jZi
"""

import json
import datetime
import google.generativeai as genai

# ✅ Configure Gemini API
GEMINI_API_KEY = "AIzaSyCB-0L4HxCKrR0gDLEnJrq5FjnkNgp8mOM"
genai.configure(api_key=GEMINI_API_KEY)

# ✅ Subjects and chapters
subjects = {
    "Physics": [
        "Physical World and Measurement", "Kinematics", "Laws of Motion", "Work, Energy, and Power",
        "Centre of Mass and Collision", "Rotation and Rolling Motion", "Gravitation", "Solids", "Fluids",
        "Thermodynamics", "Kinetic Theory of Gases", "Simple Harmonic Motion", "Waves", "Electrostatics",
        "Current Electricity", "Magnetic Effects of Current", "Material Magnetism", "Electromagnetic Induction",
        "Alternating Currents", "Electromagnetic Waves", "Ray Optics", "Wave Optics",
        "Dual Nature of Matter and Radiation", "Atoms and Nuclei", "Electronic Devices"
    ],
    "Chemistry": [
        "Some Basic Concepts of Chemistry", "Structure of Atom", "Classification of Elements and Periodicity",
        "Chemical Bonding and Molecular Structure", "Thermodynamics", "Equilibrium", "Redox Reactions",
        "General Organic Chemistry", "Hydrocarbons", "Electrochemistry", "Chemical Kinetics", "The p-Block Elements",
        "The d- and f-Block Elements", "Coordination Compounds", "Haloalkanes and Haloarenes",
        "Alcohols, Phenols, and Ethers", "Aldehydes, Ketones, and Carboxylic Acids", "Organic Compounds Containing Nitrogen",
        "Biomolecules", "Salt Analysis"
    ],
    "Biology": [
        "The Living World", "Biological Classification", "Plant Kingdom", "Animal Kingdom",
        "Morphology of Flowering Plants", "Anatomy of Flowering Plants", "Structural Organisation in Animals",
        "Cell – The Unit of Life", "Biomolecules", "Cell Cycle and Cell Division",
        "Photosynthesis in Higher Plants", "Respiration in Plants", "Plant Growth and Development",
        "Breathing and Exchange of Gases", "Body Fluids and Circulation", "Excretory Products and Their Elimination",
        "Locomotion and Movement", "Neural Control and Coordination", "Chemical Coordination and Integration",
        "Sexual Reproduction in Flowering Plants", "Human Reproduction", "Reproductive Health",
        "Principles of Inheritance and Variation", "Molecular Basis of Inheritance", "Evolution",
        "Human Health and Disease", "Microbes in Human Welfare",
        "Biotechnology – Principles and Processes", "Biotechnology and Its Applications",
        "Organisms and Populations", "Ecosystem", "Biodiversity and Its Conservation"
    ]
}

# ✅ Load chapter data from JSON file or create an empty dictionary
try:
    with open("chapters.json", "r") as f:
        chapters = json.load(f)
except FileNotFoundError:
    chapters = {}

# ✅ Function to interpret feedback using Gemini API
def get_difficulty_with_gemini(feedback):
    model = genai.GenerativeModel("gemini-1.5-pro")
    prompt = f"""
    You are a study assistant.
    Based on the following feedback, determine the difficulty level as one of:
    - very_easy
    - easy
    - medium
    - hard

    Feedback: "{feedback}"
    Return ONLY the difficulty label.
    """

    response = model.generate_content(prompt)
    difficulty = response.text.strip().lower()

    valid_difficulties = ["very_easy", "easy", "medium", "hard"]
    return difficulty if difficulty in valid_difficulties else "medium"

# ✅ Dynamic gap calculation based on feedback and previous performance
def calculate_revision_date(chapter, difficulty, missed):
    today = datetime.date.today()
    if chapter in chapters:
        last_data = chapters[chapter]
        prev_difficulty = last_data.get("difficulty", "medium")
        last_gap = (today - datetime.date.fromisoformat(last_data.get("last_studied", str(today)))).days

        # Memory decay factor with missed session penalty
        decay_factor = max(1, int(last_gap * 0.7)) if last_gap > 14 else last_gap
        if missed:
            decay_factor = max(1, decay_factor // 2)  # Reduce the gap if missed

        # Dynamic gap logic
        gap = decay_factor
        if difficulty == "hard":
            gap = max(3, decay_factor - 2)
        elif difficulty == "medium":
            gap = max(5, decay_factor - 1)
        elif difficulty == "easy":
            gap = min(14, decay_factor + 2)
        elif difficulty == "very_easy":
            gap = min(21, decay_factor + 4)

        # Adjust based on improvement or decline
        if prev_difficulty == "hard" and difficulty == "medium":
            gap += 3
        elif prev_difficulty == "medium" and difficulty == "easy":
            gap += 5
        elif prev_difficulty == "easy" and difficulty == "hard":
            gap = max(3, gap - 5)

        return today + datetime.timedelta(days=gap)

    # Default gaps for new chapters
    base_intervals = {"very_easy": 14, "easy": 10, "medium": 7, "hard": 4}
    return today + datetime.timedelta(days=base_intervals[difficulty])

# ✅ Main loop for interacting with the system
while True:
    print("\nSelect a subject:")
    for idx, subject in enumerate(subjects.keys(), 1):
        print(f"{idx}. {subject}")

    subject_choice = int(input("Enter subject number (or 0 to quit): "))
    if subject_choice == 0:
        break

    subject = list(subjects.keys())[subject_choice - 1]
    print(f"\nSelect a chapter from {subject}:")
    for idx, chapter in enumerate(subjects[subject], 1):
        print(f"{idx}. {chapter}")

    chapter_choice = int(input("Enter chapter number: "))
    chapter = subjects[subject][chapter_choice - 1]

    feedback = input("Enter your feedback on the chapter: ").strip()
    missed = input("Did you miss the previous revision? (yes/no): ").strip().lower() == "yes"

    difficulty = get_difficulty_with_gemini(feedback)
    revision_date = calculate_revision_date(chapter, difficulty, missed)

    chapters[chapter] = {
        "last_studied": str(datetime.date.today()),
        "difficulty": difficulty,
        "next_revision": str(revision_date)
    }

    with open("chapters.json", "w") as f:
        json.dump(chapters, f, indent=4)

    print(f"\n✅ Next revision for '{chapter}' on {revision_date} (Difficulty: {difficulty}, Missed: {'Yes' if missed else 'No'})\n")